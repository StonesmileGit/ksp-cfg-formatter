document = { SOI ~ "\u{FEFF}"? ~ Newline* ~ statement* ~ (Newline | Whitespace)* ~ EOI }

statement = _{ (assignment | node | Comment) ~ (EmptyLine | Newline)? }

openingbracket = { "{" }

closingbracket = { "}" }

node = { ("#" ~ path)? ~ operator? ~ nodeBeforeBlock ~ openingbracket ~ nodeBody ~ closingbracket ~ (Comment | Whitespace+)? }

nodeBeforeBlock = _{ identifier ~ nameBlock? ~ ((index ~ blocks?)|(blocks? ~ index)| blocks)? ~ Comment? ~ Newline? ~ (Whitespace* ~ Comment? ~ Newline)* ~ (Whitespace | Newline)* }

nodeBody = { (Whitespace* ~ Newline)* ~ (Whitespace* ~ statement)* ~ Newline* ~ Whitespace* }

// TODO: Where does :NEEDS go?
// TODO: '*' added here instead of adding paths
assignment = { ("*" ~ path)? ~ operator? ~ keyIdentifier ~ needsBlock? ~ index? ~ arrayIndex? ~ Whitespace* ~ assignmentOperator ~ Whitespace* ~ value ~ Comment? }

// Allowed: -_.+*? or Letter or Digit
// TODO: Should LETTER be ASCII_ALPHA?
// TODO: This is correct for nodes, but not key-value identifiers
identifier = ${ ("-" | "_" | "." | "+" | "*" | "?" | LETTER | ASCII_DIGIT)+ }

keyIdentifier = ${ ("#" | "_" | "." | (("-" | "+" | "*") ~ !"=") | ("/" ~ !("/" | "=")) | "?" | LETTER | ASCII_DIGIT)+ }

path = ${ ("@"|"/")? ~ (path_segment ~ "/")* }
path_segment = {".." | identifier ~ nameBlock? }

// TODO: | is not allowed in top level nodes
operator = { "@" | "+" | "-" | "%" | "!" | "&" | "|"}

value = ${ (!(Newline | closingbracket | "//") ~ ANY)* }

Comment = ${ Whitespace* ~ "//" ~ (!Newline ~ ANY)* }

Whitespace = _{ "\t" | SPACE_SEPARATOR }

EmptyLine = { Newline ~ Whitespace* ~ (Newline ~ Whitespace*)+ }

Newline = ${ NEWLINE }

assignmentOperator = { ("*" | "/" | "+" | "-" | "!" | "^")? ~ "=" }

// Block for targetting a node with the specified identifier, eg: @PART[NameOfPart]
// TODO: Currently identifier can be one|two, but that is only allowed at top nodes, so not @PART[blah] { @MODULE[one|two] {}}
// FIXME: Are spaces allowed?
nameBlock = { "[" ~ ((!("|" | "," | "]") ~ ANY)+ ~ (("|" | ",") ~ (!("|" | "]") ~ ANY)+)*)? ~ "]" }
// nameBlock = { "[" ~ identifier ~ "]" }

// We want there to be a max of 1 of: hasBlock, needsBlock and passBlock, but order does not matter
// ===
blocks = _{ (hasBranch | needsBranch | passBranch) }

hasBranch = _{ hasBlock ~ ((needsBlock ~ passBlock?) | (passBlock ~ needsBlock?))? }

needsBranch = _{ needsBlock ~ ((hasBlock ~ passBlock?) | (passBlock ~ hasBlock?))? }

passBranch = _{ passBlock ~ ((hasBlock ~ needsBlock?) | (needsBlock ~ hasBlock?))? }
// ===

// TODO: Only supports positive has check for property
// # for key-value
// hasBlock = { ^":HAS[" ~ ("#" ~ identifier ~ ("[" ~ identifier ~ hasBlock? ~ "]")?) ~ "]" }
hasBlock     =  { ^":HAS[" ~ (hasBlockPart ~ (("&" | ",") ~ hasBlockPart)*) ~ "]" }
hasBlockPart = { hasNode | hasKey }
// TODO: What is a valid identifier here?
// TODO: modName can contain wildcard *
// TODO: While OR is not allowed, seems like '|' as a char is...
hasNode = _{ ("@" | "!" | "-") ~ identifier ~ hasNodeName? ~ hasBlock? }
hasNodeName = { ("[" ~ (LETTER | ASCII_DIGIT | "/" | "_" | "-" | "?" | "*" | "." | "|")+ ~ "]") }

hasKey = _{ ("#" | "~") ~ identifier ~ ("[" ~ hasValue ~ "]")? }
// TODO: Is this correct?
hasValue = { (!(Newline | "]" | "//") ~ ANY)* }

needsBlock = { ^":NEEDS[" ~ modOrClause ~ (("&" | ",") ~ modOrClause)* ~ "]" }

modOrClause = { needsMod ~ ("|" ~ needsMod)* }
needsMod = { negation? ~ modName }
negation = {"!"}

passBlock = { firstPassBlock | namedPassBlock | finalPassBlock }

firstPassBlock = { ^":FIRST" }

namedPassBlock = _{ beforePass | forPass | afterPass | lastPass}
beforePass = { ^":BEFORE[" ~ modName ~ "]" }
forPass = {^":FOR[" ~ modName ~ "]" }
afterPass = {^":AFTER[" ~ modName ~ "]" }
lastPass = {^":LAST[" ~ modName ~ "]" }

modName = { (LETTER | ASCII_DIGIT | "/" | "_" | "-" | "?")+ }

finalPassBlock = { ^":FINAL" }

// TODO: what about white space?
index = { "," ~ ("*" | ("-"? ~ ASCII_DIGIT+)) }

// TODO: What about no char after ","?
arrayIndex = { "[" ~ ("*" | ASCII_DIGIT+) ~ ("," ~ ANY)? ~ "]" }
